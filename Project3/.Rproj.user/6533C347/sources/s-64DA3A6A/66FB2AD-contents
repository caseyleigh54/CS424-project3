#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#

library(shiny)
library(AotClient) 
library(darksky)
library("ropenaq")
library(lubridate)
library(tidyverse)
library(dplyr)
library(shinydashboard)
library(leaflet)
library(qdapTools)
library(data.table)
library(jsonlite)
pollutants_list = list("NO2", "Ozone", "CO", "H2S", "SO2", "PM10", "PM25", "Temperature", "Humidity", "Light")
# Define UI for application that draws a histogram
ui <- dashboardPage(
  ################################################################################ THE COLOR AND LENGTH OF THE TITLE FOR THE SIDEBAR ################################################################################
  skin = "yellow",
  dashboardHeader(title = "CS 424 PROJECT 2", titleWidth = 450 ),
  
  ######################################## CREATE DROP DOWN MENUS IN SIDEBAR + NEW TAB CONTAINING RESOURCES ######################################## 
  dashboardSidebar(sidebarMenu(disable = FALSE, collapsed = FALSE,
                               uiOutput("nodeOutput"),
                               uiOutput("node1Output"),
                               uiOutput("node2Output"),
                               selectInput("pollutants", "Pollutants", pollutants_list)
                              
  )),
  ######################################## THE MAIN BODDY OF THE WEB APP ########################################
  dashboardBody(
    fluidRow(column(6,
                    leafletOutput("mymap", height = 600)
                    ),
             column(6, h4(textOutput("Node Data")),
                    tabsetPanel(
                      tabPanel("Current",plotOutput("node_data")),
                      tabPanel("24 Hours", plotOutput("node_data24")),
                      tabPanel("7 Days",plotOutput("node_data7"))
                    ))
             ),
    fluidRow(column(6,h4(textOutput("Node 1")),
               tabsetPanel(
                 tabPanel("Current",plotOutput("node1_cur")),
                 tabPanel("24 Hours", plotOutput("node1_24")),
                 tabPanel("7 Days",tableOutput("node1_7"))
               )
             ),
             column(6,h4(textOutput("Node 2")),
                    tabsetPanel(
                      tabPanel("Current",plotOutput("node2_cur")),
                      tabPanel("24 Hours", plotOutput("node2_24")),
                      tabPanel("7 Days",plotOutput("node2_7"))
                    )
             )
    )
  ))

# Nodes - Column Names
# "vsn"               "location.type"     "location.geometry" "description"       "address" 
# vsn location.type location.geometry.type location.geometry.crs.type location.geometry.crs.name location.geometry.coordinates

# Observations - Column Names
# "value"             "uom"               "timestamp"         "sensor_path"       "node_vsn"          "location.type"     "location.geometry"

# Projects - Column Names
# "slug"        "name"        "hull"        "archive_url"

# Sensors - Column Names
# "uom"        "path"       "min"        "max"        "data_sheet"

# Define server logic required to draw a histogram
server <- function(input, output) {
  
  autoInvalidate <- reactiveTimer(1000*60)
  
  observe({
    # Invalidate and re-execute this reactive expression every time the
    # timer fires.
    autoInvalidate()
    
    # Do something each time this is invalidated.
    # The isolate() makes this observer _not_ get invalidated and re-executed
    # when input$n changes.
    print("Validated")
  })

  getNodeData2 <- function(vsn, d,h){
    url <- "https://api.arrayofthings.org/api/observations?location=chicago&node="
    url <- paste(url, vsn,"&timestamp=","ge:2018-08-01T00:00:00&size=50000", sep="")
    s <- download.file(url, "/var/tmp/obs", quiet = FALSE) 
    t = fromJSON("/var/tmp/obs")
    u = t$data
    currentTime = Sys.time();
    gmtTime = as.POSIXlt(currentTime, tz="UTC")
    int <- interval(gmtTime - hours(h) - days(d), gmtTime)
    path_list = getPollutantPaths()
    path_list = getPollutantPaths()
    print(u)
    return(select(subset(u, is.element(sensor_path, path_list) & as.POSIXlt(timestamp, tz="UTC", "%Y-%m-%dT%H:%M") %within% int), 'node_vsn', 'sensor_path', 'timestamp', 'value'))
  }
  
  
  
  no2_path = "chemsense.no2.concentration"
  ozone_path = "chemsense.o3.concentration"
  co_path = "chemsense.co.concentration"
  h2s_path = "chemsense.h2s.concentration"
  so2_path = "chemsense.so2.concentration"
  pm10_paths = list("alphasense.opc_n2.pm10", "plantower.pms7003.pm10_atm")
  pm25_paths = list("alphasense.opc_n2.pm2_5", "plantower.pms7003.pm25_atm")
  temperature_paths = list("lightsense.hih6130.temperature", 
                           "metsense.tmp112.temperature", 
                           "metsense.tsys01.temperature", 
                           "metsense.pr103j2.temperature",
                           "metsense.htu21d.temperature",
                           "metsense.bmp180.temperature",
                           "lightsense.tmp421.temperature",
                           "chemsense.lps25h.temperature",
                           "chemsense.at0.temperature",
                           "chemsense.at1.temperature",
                           "chemsense.at2.temperature",
                           "chemsense.at3.temperature")
  humidity_paths = list("metsense.hih4030.humidity",
                        "metsense.htu21d.humidity",
                        "chemsense.sht25.humidity")
  intensity_path = "chemsense.si1145.visible_light_intensity "
  
  # Use these for the check boxes
  no2_IsSelected = TRUE
  ozone_IsSelected = FALSE
  co_IsSelected = TRUE
  h2s_IsSelected = FALSE
  so2_IsSelected = FALSE
  pm10_IsSelected = FALSE
  pm25_IsSelected = FALSE
  tempertature_IsSelected = FALSE
  humidity_IsSelected = FALSE
  intensity_IsSelected = FALSE
  
  getPollutantPaths <- function(){
    pathList = list()
    if(no2_IsSelected){pathList = c(pathList, no2_path)}
    if(ozone_IsSelected){pathList = c(pathList, ozone_path)}
    if(co_IsSelected){pathList = c(pathList, co_path)}
    if(h2s_IsSelected){pathList = c(pathList, h2s_path)}
    if(so2_IsSelected){pathList = c(pathList, so2_path)}
    if(pm10_IsSelected){pathList = c(pathList, pm10_paths)}
    if(pm25_IsSelected){pathList = c(pathList, pm25_paths)}
    if(tempertature_IsSelected){pathList = c(pathList, temperature_paths)}
    if(humidity_IsSelected){pathList = c(pathList, humidity_paths)}
    if(intensity_IsSelected){pathList = c(pathList, intensity_path)}
    return(pathList)
  }
  
  getPollutantPaths()
  #& as_datetime(timestamp) %within% int

 
  theAData <- ls.observations(filters=list(project='chicago', sensor="chemsense.co.concentration",  size=2000))


  observe({
    autoInvalidate()
    theAData <- ls.observations(filters=list(project='chicago', size=2000))
  })
  
  getNodes <- function(path, d, h){
    currentTime = Sys.time();
    gmtTime = as.POSIXlt(currentTime, tz="UTC")
    int <- interval(gmtTime - hours(h) - days(d), gmtTime)
    path_list = getPollutantPaths()

    c = select(subset(theAData, is.element(sensor_path, path_list) & as.POSIXlt(timestamp, tz="UTC", "%Y-%m-%dT%H:%M") %within% int), 'node_vsn', 'sensor_path', 'timestamp', 'value')
    return (c)
  }

  
  getNodesNow <- function(path, a){
    currentTime = Sys.time();
    gmtTime = as.POSIXlt(currentTime, tz="UTC")
    int <- interval(gmtTime - hours(1), gmtTime)
    c = select(subset(theAData, as.POSIXlt(timestamp, tz="UTC", "%Y-%m-%dT%H:%M") %within% int), 'node_vsn')
    return (c)
  }
  
  # Returns all nodes and locations of currently selected items
  getNodeLocations <- function(){
    c <- getNodes("metsense.tsys01.temperature", 0, 1)
    nodes <- unique(c$node_vsn)
    node_addresses <- subset(ls.nodes(filters=list(project='chicago')), (vsn %in% nodes))

    node_a <- select(node_addresses, unique('vsn'), 'address', 'location.geometry')
    locations <- select(node_a, 'vsn', 'address')
    locations$coordinates <- select(node_a$location.geometry, 'coordinates')
    dt <- locations$coordinates
    res <- dt %>%
      rowwise %>%
      mutate(Lat = as.numeric(coordinates[1]), Lon = as.numeric(coordinates[2])) %>%
      ungroup %>%
      select(-coordinates)
    data <- cbind(locations, res)
    locations <- data
    return (locations)
  }
  
  nodeLocations <- reactive({
    autoInvalidate()
    getNodeLocations()
  })
  # Returns Data of current node selected
  getNodeData<- function(vsn, d, h){
    currentTime = Sys.time();
    gmtTime = as.POSIXlt(currentTime, tz="UTC")
    int <- interval(gmtTime - hours(h) - days(d), gmtTime)
    path_list = getPollutantPaths()
      path_list = getPollutantPaths()
      nodes <- ls.observations(filters=list(project='chicago', node_vsn='004', size=5000))
      return (select(subset(nodes, is.element(sensor_path, path_list) & as.POSIXlt(timestamp, tz="UTC", "%Y-%m-%dT%H:%M") %within% int), 'node_vsn', 'sensor_path', 'timestamp', 'value'))
  }
  
  
  getAllNodes <- function(){
    return (select(ls.nodes(filters=list(project='chicago')), 'vsn'))
  }
  
  
  output$nodeOutput <- renderUI({
    dt <- getNodesNow("metsense.tsys01.temperature")
    selectInput("nodeInput", "Current Nodes",
                dt)
  })  
  
  output$node1Output <- renderUI({
    dt <- getAllNodes()
    selectInput("node1Input", "Node 1",
                dt)
  })  
  
  output$node2Output <- renderUI({
    dt <- getAllNodes()
    selectInput("node2Input", "Node 2",
                dt)
  })  
  
  #Node selected on map current data
  curNodeData <- reactive({
    req(input$nodeInput)
    autoInvalidate()
    getNodeData2(input$nodeInput,0,1)
  })
  
  #Node selected on map last 24 hours of data
  curNodeData24 <- reactive({
    req(input$nodeInput)
    autoInvalidate()
    getNodeData(input$nodeInput, 1, 0)
  })
  
  
  #Data for node 1 selected for last 24 hours
  node1SelectedData24 <- reactive({
    req(input$node1Input)
    autoInvalidate()
    getNodeData2(input$node1Input,1,0)
  })
  
  #Data for node 2 selected for last 24 hours
  node2SelectedData24 <- reactive({
    req(input$node2Input)
    autoInvalidate()
    getNodeData2(input$node2Input,1,0)
  })
  
  #Data for node 1 selected for Current time
  node1SelectedDataCur <- reactive({
    req(input$node1Input)
    autoInvalidate()
    getNodeData2(input$node1Input,0,1)
  })
 
  #Data for node 2 selected for Current time
  node2SelectedDataCur <- reactive({
    req(input$node2Input)
    autoInvalidate()
    getNodeData2(input$node2Input,0,1)
  })
  
  #Data for node 1 selected for 7 Days
  node1SelectedData7 <- reactive({
    req(input$node1Input)
    autoInvalidate()
    getNodeData2(input$node1Input,7,0)
  })
  
  #Data for node 2 selected for 7 Days
  node2SelectedData7 <- reactive({
    req(input$node2Input)
    autoInvalidate()
    getNodeData2(input$node2Input,7,0)
  })
  
    
  ## !!!!!!!!! Turn these into histograms !!!!!!!!!
    output$node1_cur <- renderPlot({
      df <- node1SelectedDataCur()
      df$timestamp <- as.POSIXct(df$timestamp, tz="UTC", "%Y-%m-%dT%H:%M")
      ggplot(df, aes(timestamp,value,group = sensor_path))+ 
        geom_line(aes(color = factor(sensor_path))) +
        ylab('Hourly Data')
    })
    output$node1_24 <- renderPlot({
      df <- node1SelectedData24()
      df$timestamp <- as.POSIXct(df$timestamp, tz="UTC", "%Y-%m-%dT%H:%M")
      ggplot(df, aes(timestamp,value,group = sensor_path))+ 
        geom_line(aes(color = factor(sensor_path))) +
        ylab('Hourly Data')
    })
    output$node1_7 <- renderTable({
      node1SelectedData7()
      
    })
    
  ## !!!!!!!!! Turn these into histograms !!!!!!!!!
    output$node2_cur <- renderPlot({
      df <- node2SelectedDataCur()
       df$timestamp <- as.POSIXct(df$timestamp, tz="UTC", "%Y-%m-%dT%H:%M")
      ggplot(df, aes(timestamp,value,group = sensor_path))+ 
        geom_line(aes(color = factor(sensor_path))) +
        ylab('Hourly Data')

      
    })
    output$node2_24 <- renderPlot({
      df <- node2SelectedData24()
      df$timestamp <- as.POSIXct(df$timestamp, tz="UTC", "%Y-%m-%dT%H:%M")
      ggplot(df, aes(timestamp,value,group = sensor_path))+ 
        geom_line(aes(color = factor(sensor_path))) +
        ylab('Hourly Data')
      
    })
    output$node2_7 <- renderPlot({
      df <- node2SelectedData7()
      df$timestamp <- as.POSIXct(df$timestamp, tz="UTC", "%Y-%m-%dT%H:%M")
      ggplot(df, aes(timestamp,value,group = sensor_path))+ 
        geom_line(aes(color = factor(sensor_path))) +
        ylab('Hourly Data')
    })
  
  
   res <- get_current_forecast(41.870, -87.647)
   res2 <- aq_latest(country = "US", city = "Chicago-Naperville-Joliet")

   
   
   output$mymap <- renderLeaflet({
     ds <- nodeLocations()  #displays only the current nodes with information (last 1 hour)
     leaflet(ds) %>%
       addTiles() %>%  # Add default OpenStreetMap map tiles
       addMarkers(~Lat, ~Lon, popup = ~as.character(address), label = ~as.character(vsn), layerId = ~vsn)
   })
 
   observeEvent(input$mymap_marker_click, { 
     p <- input$mymap_marker_click
     data <- getNodeData2(p$id, 0, 1)
     data$timestamp <- as.POSIXct(data$timestamp, tz="UTC", "%Y-%m-%dT%H:%M")
     output$node_data <- renderPlot({
       ggplot(data=data, aes(timestamp,value,group = sensor_path)) +
         geom_line(aes(color = factor(sensor_path)))+
         geom_point() +
         ylab('Hourly Data')

     })
     output$node_data24 <- renderPlot({
       df <- getNodeData2(p$id, 0, 24)
       df$timestamp <- as.POSIXct(df$timestamp, tz="UTC", "%Y-%m-%dT%H:%M")
       ggplot(df, aes(timestamp,value,group = sensor_path))+ 
         geom_line(aes(color = factor(sensor_path))) +
         ylab('Hourly Data')
     })
     output$node_data7 <- renderPlot({
       df <- getNodeData2(p$id, 7, 0)
       df$timestamp <- as.POSIXct(df$timestamp, tz="UTC", "%Y-%m-%dT%H:%M")
       ggplot(df, aes(timestamp,value,group = sensor_path))+ 
         geom_line(aes(color = factor(sensor_path))) +
         ylab('Hourly Data')
     })
     
   })
  

   
  
}

# Run the application 
shinyApp(ui = ui, server = server)

